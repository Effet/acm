#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

// #include "../../_templetes/computational-geometry/geo2d_v2.cpp"
const double PI  = acos(-1.0);
const double TAU = 2 * PI;
const double EPS = 1e-8;

int sig(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}
template<class T> T pow2(T x) {return x * x;}


class Vector {
public:
    double x, y;
    Vector() {}
    Vector(double x, double y): x(x), y(y) {}
    
    Vector operator -() const {return Vector(-x, -y);}
    Vector operator +(const Vector &v) const {return Vector(x+v.x, y+v.y);}
    Vector operator -(const Vector &v) const {return Vector(x-v.x, y-v.y);}
    Vector operator *(const double &s) const {return Vector(x * s, y * s);}
    Vector operator /(const double &s) const {return Vector(x / s, y / s);}

    double operator *(const Vector &v) const {return x*v.x + y*v.y;}
    double operator ^(const Vector &v) const {return x*v.y - y*v.x;}

    // rotate vector (Right/Left hand)
    Vector  R(double co, double si) {return Vector(x*co-y*si, y*co+x*si);}
    Vector  L(double co, double si) {return Vector(x*co+y*si, y*co-x*si);}
    Vector  R(double th) {return R(cos(th), sin(th));}
    Vector  L(double th) {return L(cos(th), sin(th));}

    double len2() {return x*x + y*y;}
    double len()  {return sqrt(len2());}
    double ang()  {return atan2(y, x);}  // angle of vector
    Vector e(double s = 1.0) {return *this / len() * s;}
};
typedef Vector Point;
typedef vector<Point> Polygon;
// dot & cross product
double   dot(Point o, Point a, Point b) {return (a-o)*(b-o);}
double cross(Point o, Point a, Point b) {return (a-o)^(b-o);}


class Line {
public:
    Point a, b;
    Line() {}
    Line(Point a, Point b): a(a), b(b) {}
};
typedef Line Segment;
bool parallel(Line l1, Line l2) {return sig((l1.a-l1.b) ^ (l2.a-l2.b)) == 0;}
bool perpendicular(Line l1, Line l2) {return sig((l1.a-l1.b) * (l2.a-l2.b)) == 0;}


class Circle {
public:
    Point o;
    double r;
    Circle() {}
    Circle(Point o, double r): o(o), r(r) {}
    
    // interior          (d < R - r)         ----> -2
    // interior tangents (d = R - r)         ----> -1
    // concentric        (d = 0)
    // secants           (R - r < d < R + r) ---->  0
    // exterior tangents (d = R + r)         ---->  1
    // exterior          (d > R + r)         ---->  2
    int posi(Circle c) {
        double d = (o - c.o).len();
        int in = sig(d - fabs(r - c.r)), ex = sig(d - (r + c.r));
        return in<0 ? -2 : in==0? -1 : ex==0 ? 1 : ex>0? 2 : 0;
    }

    // Ensure this->posi(c) == (-1 || 1)
    Point touch(Circle c) {
        return (c.o - o).e(r);
    }

    // IMPORTANT: Ensure this->posi(c) == 0
    // chord(弦) of two circle
    // two points is ccw in *this circle
    Line chord(Circle c) {
        Vector v = c.o - o;
        double co = (pow2(r) + v.len2() - pow2(c.r)) / (2 * r * v.len());
        double si = sqrt(fabs(1.0 - pow2(co)));
        // cout << "co,si: " << co << " " << si << endl;
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }

    // IMPORTANT: Ensure this->posi(c) == (0
    // two points of interior/exterior tangents in this circle
    // two points is ccw in *this circle
    Line tangent_points(Circle c, bool interior = false) {
        Point  v = c.o - o;
        double co = (interior ? r+c.r : r-c.r) / v.len();
        double si = sqrt(1.0 - pow2(co));
        return Line(v.L(co, si).e(r) + o, v.R(co, si).e(r) + o);
    }

    // IMPORTANT: Ensure this->posi(c) == 0
    // vector for tangents
    // two start points is ccw in *this circle
    Line tangent_vector(Circle c, bool interior = false) {
        Point v = c.o - o;
        double si = (interior ? r+c.r : r-c.r) / v.len();
        double co = sqrt(1.0 - pow2(si));
        return Line(v.R(co, si).e(), v.L(co, si).e());
    }

    
    // tangent(切线) of two circle
    // return -1 mean inf tangents
    int tangent(Circle c, Line *l) {
        // concentric and same radii, has inf tangents
        if (sig((o - c.o).len()) == 0 && sig(r - c.r) == 0) return -1;
        
        int pos = this->posi(c);
        // interior, 0 tangents
        if (pos == -2) return 0;
        // interior tangents, only 1 external tangent
        if (pos == -1)
            return 1;

        Vector v = c.o - o;
        double co, si;
        co = (r - c.r) / v.len();
        si = sqrt(1.0 - pow2(co));

        // rotate (co, si) and fix length to r
        l[0] = Line(o + v.L(co, si).e(r),
                    o + v.R(co, si).e(r));
        l[2] = Line(c.o + (-v).L(-co, si).e(c.r),
                    c.o + (-v).R(-co, si).e(c.r));

        // secants, only this 2 external tangents
        if (pos == 0)
            return 2;

        // exterior tangent, 2 external tangents and 1 internal tangent
        if (pos ==  1) {
            Vector u(v.y, -v.x);
            l[3] = Line(o + v.e(r), o + v.e(r) + u);
            return 3;
        }

        // exterior tangent, 2 external tangents and 2 internal tangents
        if (pos == 2) {
            co = (r + c.r) / v.len();
            si = sqrt(1.0 - pow2(co));
            l[3] = Line(o + v.L(co, si).e(r),
                        o + v.L(co, si).e(r));
            l[4] = Line(c.o + (-v).L(-co, si).e(c.r),
                        c.o + (-v).R(-co, si).e(c.r));
            return 4;
        }
    }
};


class Range {
public:
    double th;
    int t;
    Range() {}
    Range(double th, int t): th(th), t(t) {}

    bool operator <(const Range &r) const {
        return sig(th - r.th) < 0 || (sig(th - r.th) == 0 && t > r.t);
    }
};


int mx, cnt;
double tha;
double fix_sqrt(double x){return x < 0 ? 0 : x;}
double fix_p_theta(double th) {return th < -EPS ? th + TAU : th;}
double fix_arc(double x) {return x < -1 ? -1 : x > 1 ? 1 : x;}
void get_ans(vector<Circle> &Ci)
{
    mx = -1; cnt = 0; tha = 0;
    int n = Ci.size();
    for (int i = 0; i < n; i++) {
        vector<Range> Rg;
        int nc = 1;
        for (int j = 0; j < n; j++) {
            if (j == i)
                continue;

            int pd = Ci[i].posi(Ci[j]);
            if (pd == 2) continue;

            Line l;
            if (pd == -1)
                l.a = l.b = Ci[j].o;
            else
                l = Ci[i].chord(Ci[j]);

            double jR = (l.a - Ci[i].o).ang(), jL = (l.b - Ci[i].o).ang();
            if (sig(jR - jL) > 0)
                nc++;

            Rg.push_back(Range(jR,  1));
            Rg.push_back(Range(jL, -1));

        }
        sort(Rg.begin(), Rg.end());
        
        if (nc > mx)
            mx = nc, cnt = 1;
        else if (nc == mx)
            cnt++;

        int k = Rg.size();
        for (int j = 0; j < k; j++) {
            nc += Rg[j].t;
            if (i == k - 1 && Rg[i].t == 1)
                break;
            if (nc > mx)
                mx = nc, cnt = 1;
            else if (nc == mx)
                cnt++;
        }
    }
}

int main(int argc, char *argv[])
{
    int t;
    cin >> t;
    while (t--) {
        // cout << "t:" << t << endl;
        double d;
        int n;
        cin >> d >> n;
        vector<Circle> C(n);
        for (int i = 0; i < n; i++) {
            cin >> C[i].o.x >> C[i].o.y;
            C[i].r = d;
        }
        get_ans(C);
        // cout << "cnt: " << cnt << endl;
        if (mx == -1)
            cout << 1 << " " << n << endl;
        else
            cout << mx << " " << cnt / mx << endl;
    }
    return 0;
}
