typedef __int64 L;
typedef unsigned __int64 UL;
const int COUNT = 6;

L fMultiModular(const L & a, L b, const L & n){
	L back(0), tmp(a%n);
	while(b>0){
		if(b&0x1){
			if((back = back+tmp)>n)
				back -= n;
		}
		if((tmp <<= 1)>n)
			tmp -= n;
		b >>= 1;
	}
	return back;
}
L modular_exp(const L & a, L b, const L & n){
	L d(1), tmp(a%n);
	while(b>0){
		if(b&0x1)
			d = fMultiModular(d, tmp, n);
		tmp = fMultiModular(tmp, tmp, n);
		b >>= 1;
	}
	return d;
}
L GCD(L a, L b){
	L c;
	while(b){
		c = b;
		b = a%b;
		a = c;
	}
	return a;
}
L pollard_rho(const L & c, const L & num){
	int i(1), k(2);
	L x = rand()%num;
	L y = x, comDiv;
	do{
		i++;
		if((x = fMultiModular(x, x, num)-c)<0)
			x += num;
		if(x==y)
			break;
		comDiv = GCD((y-x+num)%num, num);
		if(comDiv>1&&comDiv<num)
			return comDiv;
		if(i==k){
			y = x;
			k <<= 1;
		}
	}while(1);
	return num;
}
bool fWitNess(const L & a, const L & n, char t, const L & u){
	L x, y;
	x = modular_exp(a, u, n);
	while(t--){
		y = fMultiModular(x, x, n);
		if(y==1&&x!=1&&x!=n-1)
			return true;
		x = y;
	}
	return y!=1;
}
bool miller_rabin(const L & n, int cnt){
	if(n==1)
		return false;
	if(n==2)
		return true;
	L a, u;
	char t(0);
	for(u = n-1; !(u&0x1); u >>= 1)
		t++;
	for(int i = 1; i<=cnt; i++){
		a = rand()%(n-1)+1;
		if(fWitNess(a, n, t, u))
			return false;
	}
	return true;
}