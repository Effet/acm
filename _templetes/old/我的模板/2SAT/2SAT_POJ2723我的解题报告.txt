/*
 * Problem name: Get Luffy Out
 *  Solved when: 2011-8-14
 *       Author: nesua
 *  Description: 1到m层牢房，每层牢房可以由2种钥匙的其中一把开启，钥匙一共n对（各不相同的n*2把），
 *  每对中只能选择一把（即a,b中若选择了a，就不能选择b）。问题是按照从1,2,3,4...的顺序走下去，
 *  最多能走到第几层。
 *      解题思路: 2SAT。
 *      N = 2*n把钥匙分别编号b1,b2...bN。
 *      bi个钥匙或者选或者不选，则可以拆分成两种情况的集合，Bi* = (bi, ~bi);
 *      bi为选择了第i把钥匙（真），~bi为未选（假）。那么对于所有bi,~bi的集合：
 *      B = (b1, b2, ... bN, ~b1, ~b2, ... ~bN);所有选择钥匙的情况均是B的子集。
 *      令(fi1, fi2)为第i对钥匙，(gi1,gi2)为能开启第i层的2把钥匙。
 *      设f,g为B上的函数。（令fi1,fi2为真，~fi2,~fi2为假，g同样）
 *      (fi1,fi2)中二者择一或者都不选，取其补集的补就是 ~(fi1∧fi2) （非二者的交）
 *      也就是(~fi1∨~fi2)（二者非的并）
 *         对于f有F = (~f11∨~f12)∧(~f21∨~f22)...∧(~fN1∨~fN2);
 *      假设可以走num层，那么每层至少选一把钥匙，gi1,gi2二者选一或者是都选，
 *      即(gi1∨gi2)（二者的并）
 *         那么对于g有G = (g11∨g12)∧(g21∨g22)...∧(gnum1∨gnum2);
 *      问题即是最大的num使布尔函数 F∧G 适应 [SAT (Satisfiability)]
 *      这里的f,g函数可能取值只有两种（真或假），所以是2SAT。
 *      F∧G 为析取范式(Disjunctive normal form)，对于每一项(~fi1∨~fi1)或(gi1, gi2)
 *      可以拆分成 （对于A，B布尔变量~A→B（如果非A则B） 或者~B→A（如果非B则A）
 *                   有且只有他们与 A∨B 同真假）
 *         fi1  →  ~fi2  or   fi2  →  ~fi1
 *        ~gi1  →   gi2  or  ~gi2  →   gi1;
 *      二分枚举所有num的情况，按照如上拆分方式建边后，查看对于bi, ~bi是否属于同一强连通分支，
 *      存在则无法走到num层，反之则可以。
 *      难易程度: ★★★★★★
 */


//kosaraju
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAX_N = (1<<10) + 10;
const int MAX_M = (1<<11) + 10;
typedef struct forward_table{int to, next;}FwdT; //链式前向星

int n, m;
int pn[MAX_N<<1], pm[MAX_M<<1];
bool readin() {
   scanf("%d%d", &n, &m);
   if(n == 0 && m == 0){ return false; }
   for(int i=0;i<(n<<1);i++)
      scanf("%d", &pn[i]);
   for(int i=0;i<(m<<1);i++)
      scanf("%d", &pm[i]);
   return true;
}

const int MAX_VETX = MAX_N<<2;
const int MAX_EDGE = (MAX_N<<1) + (MAX_M<<1);
FwdT F[MAX_EDGE], rF[MAX_EDGE];
int head[MAX_VETX], rhead[MAX_VETX];
void insertDirectEdge(int i, int u, int v){
   F[i].to = v; F[i].next = head[u]; head[u] = i;//正图
   rF[i].to= u;rF[i].next =rhead[v];rhead[v] = i;//反图
}
void computeGraph(int num){
   for(int i=0; i<(n<<2); i++) head[i] = rhead[i] = -1;
   for(int i=0; i<(n<<1)+(num<<1); i++) F[i].next = rF[i].next = -1;

   for(int i=0;i<n;i++){
      insertDirectEdge(i<<1, pn[i<<1], pn[i<<1|1] + (n<<1));
      insertDirectEdge(i<<1|1, pn[i<<1|1], pn[i<<1] + (n<<1));
   }
   for(int i=0;i<num;i++){
      insertDirectEdge((n<<1) + (i<<1), pm[i<<1] + (n<<1), pm[i<<1|1]);
      insertDirectEdge((n<<1) + (i<<1|1), pm[i<<1|1] + (n<<1), pm[i<<1]);
   }
}

int f[MAX_VETX], time;
bool cover[MAX_VETX];
void DFS_Visit(int u) {
   cover[u] = true;
   for (int i = head[u]; i!=-1; i=F[i].next)
      if (!cover[F[i].to]){ DFS_Visit(F[i].to);}
   f[time++] = u;
}
void DFS(){
   for (int i = 0; i < (n<<2); i++)
      cover[i] = false;
   time = 0;
   for (int i = 0; i < (n<<2); i++)
      if (!cover[i]){ DFS_Visit(i);}
}
int belg[MAX_VETX], sig;
void DFS_Visit_2(int u) {
   cover[u] = true;
   for (int i = rhead[u]; i!=-1; i=rF[i].next)
      if (!cover[rF[i].to]){ DFS_Visit_2(rF[i].to);}
   belg[u] = sig;
}
void DFS_2() {
   for (int i = 0; i < (n<<2); i++)
   { cover[i] = false; belg[i] = -1;}
   sig = 0;
   for (int i = time-1; i >= 0; i--)
      if (!cover[f[i]]){++sig;DFS_Visit_2(f[i]);}
}

void kosaraju(int num) {//到第几层
   computeGraph(num);
   DFS(); DFS_2();
}

bool _2sat(int num){
   kosaraju(num);
   for(int i=0;i<(n<<1);i++)
      if(belg[i]==belg[i+(n<<1)]){return false;}
   return true;
}

void solv(){
   int l=1, r = m, mid, ans = 0;
   while(l <= r){
      mid = (l+r)>>1;
      if(!_2sat(mid)){ r = mid - 1;}
      else{ ans = mid; l = mid + 1;}
   }
   printf("%d\n", ans);
}

int main() {
   freopen("POJ.in", "r", stdin);
   while ( readin() ){
      solv();
   }
   return 0;
}


//tarjan求强连通，速度没有加快
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
const char NOTVIS = 0x00;
const char VIS = 0x01;
const char OVER = 0x02;
const int MAX_N = (1<<10) + 10;
const int MAX_M = (1<<11) + 10;
typedef struct forward_table{int to, next;}FwdT; //链式前向星

int n, m;
int pn[MAX_N<<1], pm[MAX_M<<1];
bool readin() {
   scanf("%d%d", &n, &m);
   if(n == 0 && m == 0){ return false; }
   for(int i=0;i<(n<<1);i++)
      scanf("%d", &pn[i]);
   for(int i=0;i<(m<<1);i++)
      scanf("%d", &pm[i]);
   return true;
}

const int MAX_VETX = MAX_N<<2;
const int MAX_EDGE = (MAX_N<<1) + (MAX_M<<1);
FwdT F[MAX_EDGE];
int head[MAX_VETX];
void insertDirectEdge(int i, int u, int v){
   F[i].to = v; F[i].next = head[u]; head[u] = i;
}
void computeGraph(int num){
   for(int i=0; i<(n<<2); i++) head[i] = -1;
   for(int i=0; i<(n<<1)+(num<<1); i++) F[i].next = -1;

   for(int i=0;i<n;i++){
      insertDirectEdge(i<<1, pn[i<<1], pn[i<<1|1] + (n<<1));
      insertDirectEdge(i<<1|1, pn[i<<1|1], pn[i<<1] + (n<<1));
   }
   for(int i=0;i<num;i++){
      insertDirectEdge((n<<1) + (i<<1), pm[i<<1] + (n<<1), pm[i<<1|1]);
      insertDirectEdge((n<<1) + (i<<1|1), pm[i<<1|1] + (n<<1), pm[i<<1]);
   }
}

char flag[MAX_VETX];
int stck[MAX_VETX];//stack
int mlik[MAX_VETX], indx[MAX_VETX];
int belg[MAX_VETX];
int sig, scc_num;
void DFS_Visit(int u){
   stck[++stck[0]] = u; flag[u] = VIS;
   mlik[u] = indx[u] = ++sig;
   for(int i=head[u];i!=-1;i=F[i].next){
      if(NOTVIS == flag[F[i].to]){
         DFS_Visit(F[i].to);
         if(mlik[u] > mlik[F[i].to]){ mlik[u] = mlik[F[i].to];}
      }
      else if(VIS == flag[F[i].to]){
         if(mlik[u] > mlik[F[i].to]){ mlik[u] = mlik[F[i].to];}
      }
   }
   if( mlik[u] == indx[u] ){
      ++scc_num;
      do{
         belg[stck[stck[0]]] = scc_num;
         flag[stck[stck[0]]] = OVER;
      }while( stck[stck[0]--]!=u);
   }
}

void DFS(){
   for(int i=0;i<(n<<2);i++)
   { flag[i] = NOTVIS;}
   sig = 0; scc_num = 0; stck[0] = 0;
   for(int i=0;i<(n<<2);i++)
      if(NOTVIS==flag[i]){ DFS_Visit(i);}
}

void tarjan(int num){
   computeGraph(num);
   DFS();
}

bool _2sat(int num){
   tarjan(num);
   for(int i=0;i<(n<<1);i++)
      if(belg[i]==belg[i+(n<<1)]){return false;}
   return true;
}

void solv(){
   int l=1, r = m, mid, ans = 0;
   while(l <= r){
      mid = (l+r)>>1;
      if(!_2sat(mid)){ r = mid - 1;}
      else{ ans = mid; l = mid + 1;}
   }
   printf("%d\n", ans);
}

int main() {
   freopen("POJ.in", "r", stdin);
   while ( readin() ){
      solv();
   }
   return 0;
}

//gabow强连通
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX_N = (1<<10) + 10;
const int MAX_M = (1<<11) + 10;
typedef struct forward_table{int to, next;}FwdT; //链式前向星

int n, m;
int pn[MAX_N<<1], pm[MAX_M<<1];
bool readin() {
   scanf("%d%d", &n, &m);
   if(n == 0 && m == 0){ return false; }
   for(int i=0;i<(n<<1);i++)
      scanf("%d", &pn[i]);
   for(int i=0;i<(m<<1);i++)
      scanf("%d", &pm[i]);
   return true;
}

const int MAX_VETX = MAX_N<<2;
const int MAX_EDGE = (MAX_N<<1) + (MAX_M<<1);
FwdT F[MAX_EDGE];
int head[MAX_VETX];
void insertDirectEdge(int i, int u, int v){
   F[i].to = v; F[i].next = head[u]; head[u] = i;
}
void computeGraph(int num){
   for(int i=0; i<(n<<2); i++) head[i] = -1;
   for(int i=0; i<(n<<1)+(num<<1); i++) F[i].next = -1;

   for(int i=0;i<n;i++){
      insertDirectEdge(i<<1, pn[i<<1], pn[i<<1|1] + (n<<1));
      insertDirectEdge(i<<1|1, pn[i<<1|1], pn[i<<1] + (n<<1));
   }
   for(int i=0;i<num;i++){
      insertDirectEdge((n<<1) + (i<<1), pm[i<<1] + (n<<1), pm[i<<1|1]);
      insertDirectEdge((n<<1) + (i<<1|1), pm[i<<1|1] + (n<<1), pm[i<<1]);
   }
}

int intm[MAX_VETX];//in time
int belg[MAX_VETX];
int stk1[MAX_VETX], stk2[MAX_VETX];//stack
int time, scc_num;
void DFS_Visit(int cur){
   intm[cur] = ++time;
   stk1[++stk1[0]] = cur;
   stk2[++stk2[0]] = cur;
   for(int i=head[cur];i!=-1;i=F[i].next){
      if(intm[F[i].to] == 0){ DFS_Visit(F[i].to);}
      else if(belg[F[i].to] == 0){
         while(intm[stk2[stk2[0]]] > intm[F[i].to])
         { -- stk2[0];}
      }
   }
   if(stk2[stk2[0]] == cur){
      -- stk2[0]; ++ scc_num;
      do{ belg[stk1[stk1[0]]] = scc_num;}
      while( stk1[stk1[0]--]!=cur );
   }
}

void DFS(){
   for(int i=0;i<(n<<2);i++)
   { intm[i] = 0; belg[i] = 0;}
   time = 0; scc_num = 0; stk1[0] = 0; stk2[0] = 0;
   for(int i=0;i<(n<<2);i++)
      if(intm[i]==0){ DFS_Visit(i);}
}

void gabow(int num){
   computeGraph(num); DFS();
}

bool _2sat(int num){
   gabow(num);
   for(int i=0;i<(n<<1);i++)
      if(belg[i]==belg[i+(n<<1)]){return false;}
   return true;
}

void solv(){
   int l=1, r = m, mid, ans = 0;
   while(l <= r){
      mid = (l+r)>>1;
      if(!_2sat(mid)){ r = mid - 1;}
      else{ ans = mid; l = mid + 1;}
   }
   printf("%d\n", ans);
}

int main() {
   freopen("POJ.in", "r", stdin);
   while ( readin() ){
      solv();
   }
   return 0;
}
