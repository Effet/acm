#+TITLE: Algorithm & Formulas For ACM/ICPC
#+OPTIONS: num:t toc:t \n:nil TeX:t LaTeX:t
#+STARTUP: hideblocks
#+MATHJAX: align:"left"

* Divide & Conquer 分治
** Binary Search 二分查找
#+include "~/acm/_templetes/divide-and-conquer/binary-search/二分.cpp" src cpp
*** 二分离散
#+include "~/acm/_templetes/divide-and-conquer/binary-search/二分离散.cpp" src cpp

** Divide Tree 划分树
- Refers to:
  - http://www.notonlysuccess.com/index.php/divide-tree/
  - http://acm.bjtu.edu.cn:8080/wiki/?tag=%E5%88%92%E5%88%86%E6%A0%91
#+include "~/acm/_templetes/divide-and-conquer/divide-tree/divide-tree-1.cpp" src cpp

** Tree Reconstruction 树重建
- 已知先序序列 & 中序序列， 求后序序列：
#+include "~/acm/_templetes/divide-and-conquer/tree-reconstruction(树重建)/已知先序序列中序序列求后序序列.cpp" src cpp

* right-to-left binary method
** right-to-left binary exponentiation
http://primes.utm.edu/glossary/xpage/BinaryExponentiation.html
** Fast Fibonacci
#+include "~/acm/_templetes/divide-and-conquer/fast-fibonacci.cpp" src cpp
- [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3914][UVA/12470 - Tribonacci]]
  - A: 矩阵连乘Fibonacci扩展。

* Number Theory 数论
** GCD (Greatest Common Divisor) 最大公约数
*** Euclidean Algorithm 辗转相除法
- \(\gcd(a, b) = \gcd(b, a \bmod b)\)
#+include "~/acm/_templetes/number-theory/gcd/gcd.cpp" src cpp

- 非递归形式
#+include "~/acm/_templetes/number-theory/gcd/gcd-non-recursion.cpp" src cpp

*** Extended GCD
- [[http://zh.wikipedia.org/wiki/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86][Bézout's identity 裴蜀定理]]\\
  对任意两个整数\(a\)、\(b\)，设\(d\)是它们的最大公约数。
  那么关于未知数\(x\)和\(y\)的线性丢番图方程（称为裴蜀等式）：
  \[ax + by = m\]
  有整数解\((x，y)\)当且仅当\(m\)是\(d\)的倍数。裴蜀等式有解时必然有无穷多个解。
  \(m=1\)时，方程有解当且仅当\(a\)、\(b\)互质。

  方程有解时，解的集合是
  \[
  \left\{\left(\frac{m}{d}\left(x0 + k\frac{b}{d}\right), \frac{m}{d}\left(y0 - k\frac{a}{d}\right)\right) \mid k\in\mathbb{Z} \right\}
  \]
  其中\((x0,y0)\)是方程\(ax + by = d\)的一个解，可由辗转相除法得到。
  所有解中，有且仅有一个解\((x,y)\)满足\(-b \leq x \leq b\)，\(-a \leq y \leq a\)。

#+include "~/acm/_templetes/number-theory/gcd/extend-gcd.cpp" src cpp

** Prime Numbers 素数
- [[http://en.wikipedia.org/wiki/Prime-counting_function#Table_of_.CF.80.28x.29.2C_x_.2F_ln_x.2C_and_li.28x.29][素数个数]]
   |     x |                        \pi(x) |
   |-------+-------------------------------|
   |   <r> |                           <r> |
   |    10 |                             4 |
   |  10^2 |                            25 |
   |  10^3 |                           168 |
   |  10^4 |                         1,229 |
   |  10^5 |                         9,592 |
   |  10^6 |                        78,498 |
   |  10^7 |                       664,579 |
   |  10^8 |                     5,761,455 |
   |  10^9 |                    50,847,534 |
   | 10^10 |                   455,052,511 |
   | 10^11 |                 4,118,054,813 |
   | 10^12 |                37,607,912,018 |
   | 10^13 |               346,065,536,839 |
   | 10^14 |             3,204,941,750,802 |
   | 10^15 |            29,844,570,422,669 |
   | 10^16 |           279,238,341,033,925 |
   | 10^17 |         2,623,557,157,654,233 |
   | 10^18 |        24,739,954,287,740,860 |
   | 10^19 |       234,057,667,276,344,607 |
   | 10^20 |     2,220,819,602,560,918,840 |
   | 10^21 |    21,127,269,486,018,731,928 |
   | 10^22 |   201,467,286,689,315,906,290 |
   | 10^23 | 1,925,320,391,606,803,968,923 |
*** Sieve of Eratosthenes 素数筛选法
#+include "~/acm/_templetes/number-theory/prime/prime.cpp" src cpp
** Modular Arithmetic 模运算
*** Modular Exponentiation 快速幂取模
#+include "~/acm/_templetes/divide-and-conquer/fast-exponentiation/fastpow.cpp" src cpp
http://stackoverflow.com/questions/9818129/fastest-algorithm-to-compute-a2nm

*** Modular Multiplicative Inverse 乘法逆元
*** Congruence 同余
- [[http://zh.wikipedia.org/wiki/%E5%90%8C%E4%BD%99#.E6.80.A7.E8.B4.A8][性质]]
  - \(\large a \equiv b \pmod{m} \Rightarrow m | (a-b)\)

  - 传递性
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    b \equiv c \pmod{m}
    \end{matrix} \right\} \Rightarrow a \equiv c \pmod{m}
    \]

  - 加减
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    c \equiv d\pmod{m}
    \end{matrix} \right\} \Rightarrow \left\{ \begin{matrix} a \pm c \equiv b \pm d \pmod{m} \\ ac \equiv bd \pmod{m} \end{matrix} \right.
    \]

  - 变小
    \[a \equiv b \pmod{cn} \Rightarrow a \equiv b \pmod n\]
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m} \\
    n|m
    \end{matrix} \right\} \Rightarrow a \equiv b \pmod n
    \]

  - 线性同余解的性质
    \[
    \left. \begin{matrix}
    a \equiv b \pmod{m_1} \\
    a \equiv b \pmod{m_2} \\
    \vdots \\
    a \equiv b \pmod{m_n} \\
    (n \ge 2)
    \end{matrix} \right\} \Rightarrow a \equiv b \pmod{lcm(m_1,m_2,\cdots,m_n)}
    \]

*** Linear Congruence Theorem 线性同余方程
see: http://zh.wikipedia.org/wiki/线性同余方程

形如 \(ax \equiv b \pmod{n}\) 的方程当且仅当 \(\gcd(a,n)|b\) 时有解，解为
\[
\left\{ x_0 + k\frac{n}{\gcd(a,n)} \mid k \in \mathbb{Z} \right\}.
\]
在 \(\mod{n}\) 的完全剩余系 \({0,1,\cdots,n-1}\) 中，恰有 \(d\) 个解。

- 求解\\
  若 \(\gcd(a,n)|b\) ，
  由裴蜀定理，存在整数对 \((r,s)\) 使得 \(ar + sn = \gcd(a,n)\)，因此 \(\large x = r\frac{b}{\gcd(a,n)}\) 是方程的一个解。
  其他的解都关于 \(\large\frac{n}{\gcd(a,n)}\) 与 \(x\) 同余。

*** Chinese Remainder Theorem 中国剩余定理 (线性同余方程组)
- 定义
  \(n_1,n_2,\cdots,n_k\) 两两互质，对于序列\(a_1,a_2,\cdots,a_k\)，满足以下同余方程组，求解 \(x\) 。
  \[
  \begin{align}
  x &\equiv a_1 \pmod{n_1} \\
  x &\equiv a_2 \pmod{n_2} \\
  &{}\  \  \vdots \\
  x &\equiv a_k \pmod{n_k}
  \end{align}
  \]

see: http://www.stubc.com/thread-2918-1-7.html
#+include "~/acm/_templetes/number-theory/modular-arithmetic/chinese-remainder-1.cpp" src cpp

- [[http://acm.fzu.edu.cn/problem.php?pid=1402][FZU/1402 - 猪的安家]]
  - A: 模板题

对于一般的情况（即 \(n_1,n_2,\cdots,n_k\) 不两两互质），则满足
\[
a_i \equiv a_j \pmod{\gcd(n_i,n_j)} \qquad \text{for all }i\text{ and }j.
\]
时，[[http://en.wikipedia.org/wiki/Chinese_remainder_theorem#Theorem_statement][有解]]。

see: http://en.wikipedia.org/wiki/Chinese_remainder_theorem#Solution_for_non-coprime_moduli\\
see: http://yzmduncan.iteye.com/blog/1323599\\
see: http://scturtle.is-programmer.com/posts/19363
#+include "~/acm/_templetes/number-theory/modular-arithmetic/chinese-remainder-non-coprime.cpp" src cpp

- [[http://poj.org/problem?id%3D2891][POJ/2891 - Strange Way to Express Integers]]
  - A: 模板题
- [[http://acm.hdu.edu.cn/showproblem.php?pid=1573][HDU/1573 - X问题]]
  - Q: 求非互质同余方程组解\(1 \leq x \leq n\)的个数
  - A: 注意0不是解
*** Fermat's little theorem 费马小定理
- 若\(p\)为质数，\(\large a^{p} \equiv a \pmod{p}\)
- 若\(a\)不是\(p\)的倍数，\(\large a^{p-1} \equiv 1 \pmod{p}\)
*** Euler's theorem 欧拉定理
- 若\(a\),\(n\)互质，\(\large a^{\varphi(n)} \equiv 1 \pmod{n}\)
- 求\(\varphi(n)\)
#+include "~/acm/_templetes/number-theory/euler/euler.cpp" src cpp
- 预处理版本
#+include "~/acm/_templetes/number-theory/euler/euler-pre.cpp" src cpp

*** 指数循环节
- [[http://hi.baidu.com/aekdycoin/item/e493adc9a7c0870bad092fd9][AC大牛blog]]
\(x \geq \varphi(n)\)时，
\[
\Large A^x \equiv A^{x \mod \varphi(C) + \varphi(C)} \pmod{C}
\]
** Factorial 阶乘
*** 素因子 p 在 n! 中的个数
#+include "~/acm/_templetes/number-theory/prime/how-many-p-in-factorial-n.cpp" src cpp

** Digital Roots 数根
see: http://en.wikipedia.org/wiki/Digital_root
- [[http://poj.org/problem?id=1519][POJ/1519 - Digital Roots]] / [[http://acm.hdu.edu.cn/showproblem.php?pid=1013][HDU/1013 - Digital Roots]]
  - A: \(dr(n) = 1 + [n-1\pmod 9]\)

** 应用/综合
- [[http://acm.hdu.edu.cn/showproblem.php?pid%3D4335][HDU/4335 - What is N?]]
  - Q: 满足\(n^{n!} \equiv b \pmod{P} : (0 \leq n \leq M)\) 的 n 有几个。
    其中 \(0 \leq p \leq 10^5, 1 \leq M \leq 2^{64} - 1\)\\
  - A: 利用指数的循环节，小范围暴力\(0 \leq n \leq P\)即可。

* 数学
- [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3907][UVA/12464 - Professor Lazy, Ph.D.]]
  - A: 《具体数学》第一章课后习题，循环节为5。

- [[http://acm.hdu.edu.cn/showproblem.php?pid=4350][HDU/4350 - Card]]
  - A: 可从相对位置不变（环）推得，最小循环长度为\(\frac{R}{\gcd(R,R-L+1)}\)。

- [[http://acm.hdu.edu.cn/showproblem.php?pid=4359][HDU/4359 - Easy Tree DP?]]
  - Q: 构建二叉树，N个节点值分别为\(2^0,2^1,\cdots,2^{n-1}\)，求规定深度为D时，不同构建的种类数。
    （其中若某节点存在左右子树时，须满足左子树所有节点和小于右子树所有节点和）
  - A: 因为只需要保持相对关系即可，所有的状态可压缩到dp[N][D]（表示N个点D深度的二叉树的种类数）并乘以组合种类。

* TODO 博弈
# - [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3913][UVA/12469 - Stones]]
#   - Q: 
#   - A:
http://www.chenyajun.com/2010/06/22/4360

* 概率
** 全概率
- [[http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3904][UVA/12461 - Airplane]]
  - Q: N人 *依次入座* ，第一个人随机坐1~N号座位，
    其他人(i号人)若i号座位没有被占则坐i号座位，否则剩下空的位置随机坐，
    问N号人不坐自己位置的概率。
  - A: 《编程之美》 - 金刚坐飞机问题。其中第i个人坐自己位置的概率 \(\large P(i)=\frac{N-i+1}{N-i+2}\)

* Computational Geometry 计算几何
** 向量旋转
- \(\vec{OA}\) 逆时针旋转 \beta rad，并将长度缩放为 scale 倍，返回 \(B\) 点。
#+include "~/acm/_templetes/computational-geometry/vector_rotate.cpp" src cpp
- 求 \(\vec{OA}\) 绕 \(O\) 逆时针旋转至 \(\vec{OB}\) 经过的弧长。
#+include "~/acm/_templetes/computational-geometry/circle.cpp" src cpp
** Convex Hull 凸包
*** Monotone Chain Convex 扫描线法
- http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull
#+include "~/acm/_templetes/computational-geometry/convex-hull(凸包)/Monotone_Chain_Convex.cpp" src cpp
* String Algorithm 字符串
** KMP
- [[http://www.matrix67.com/blog/archives/115][matrix67'blog]] 中基于算法导论的KMP算法：
#+include "~/acm/_templetes/string/KMP/KMP-1.cpp" src cpp

- 浙大模板中稍有不同的KMP算法：
#+include "~/acm/_templetes/string/KMP/KMP-2.cpp" src cpp

*** 字符串最小循环节
- 基于KMP。
#+include "~/acm/_templetes/string/KMP/字符串最小循环节/circle.cpp" src cpp

- 例题：poj2406
*** 扩展KMP

** trie 字典树
- 例题：poj3630
#+include "~/acm/_templetes/string/trie/POJ_3630_Phone_List_字典树_trie_也可推理简化问题枚举求解_静态字典树_可略作参考_3.5_stars.cpp" src cpp

** AC自动机
- 来源：http://hi.baidu.com/%CE%D2%BF%E0%B0%A155/blog/item/7a96fbf35e7ff3db7831aa5b.html
#+include "~/acm/_templetes/string/ac-automation/build_ac_自动机_非指针.cpp" src cpp
fail指针原则：fail指针的构造关键是找到即是当点匹配串的后缀，又是trie中一个模式串的前缀的最长的字符串。
see: http://plussai.iteye.com/blog/1143023

** 字符串最小表示
- copied from http://whitedeath.is-programmer.com/posts/18404.html
#+include "~/acm/_templetes/string/字符串最小表示.cpp" src cpp

** Subsequence & Substring 子序列 & 子串 问题
*** LCPS (Longest Common Palindromic Subsequence) 最长公共回文子序列
- \(\mathcal{O}(n^4)\)
#+include "~/acm/_templetes/string/subsequence-substring/longest-common-palindromic-subsequence/LCPS-dp.cpp" src cpp
*** LIS (Longest Increasing Subsequence) 最长上升（不降）子序列
- \(\mathcal{O}(n\log{n})\) 算法
#+include "~/acm/_templetes/string/subsequence-substring/longest-increasing-subsequence/nlogn-lis.cpp" src cpp
- usaco 4.3（经典LIS模板）
#+include "~/acm/_templetes/string/subsequence-substring/longest-increasing-subsequence/usaco 4.3(经典LIS模板).cpp" src cpp
- \(\mathcal{O}(n^2)\) 算法
#+include "~/acm/_templetes/string/subsequence-substring/longest-increasing-subsequence/O(n^2)-最长不下降子序列.cpp" src cpp
- 求长度为最长上升子序列的序列个数
#+include "~/acm/_templetes/string/subsequence-substring/longest-increasing-subsequence/同求长度为最长上升子序列的序列个数.cpp" src cpp
*** LPS (Longest Palindromic Substring) 最长回文子串
- Manacher
#+include "~/acm/_templetes/string/subsequence-substring/longest-palindromic-substring/Manacher1.cpp" src cpp
* Range Query Algorithm 区间查询算法
** Segment Tree 线段树
- 浙大模板注解：
#+include "~/acm/_templetes/old/浙大模板注解/浙大线段树模板（注释）.txt" src cpp

** Fenwick Tree (Binary Indexed Tree) 树状数组
- 一维
#+include "~/acm/_templetes/range-query/binary-indexed-tree/binary-indexed-tree.cpp" src cpp
- 二维
#+include "~/acm/_templetes/range-query/binary-indexed-tree/binary-indexed-tree-2d.cpp" src cpp

** RMQ-LCA
** TODO RMQ-ST
- copied from: http://www.cppblog.com/acmiyou/archive/2009/05/18/83278.aspx
#+include "~/acm/_templetes/range-query/RMQ/RMQ-ST.cpp" src cpp

* Graph Theory 图论
** 二分图匹配
*** hungary 匈牙利算法
- 浙大模板注解：
#+include "~/acm/_templetes/old/浙大模板注解/二分图最大匹配(hungary邻接阵形式).txt" src cpp

* bit-mask 状态压缩

* Hash 哈希
- poj3349(哈希，最小表示):
#+include "~/acm/_templetes/old/我的模板/哈希表/哈希-最小表示POJ3349.cpp" src cpp

* 优化
** 单调优化
*** stack 栈
- [[http://www.spoj.pl/problems/CITY2/][SPOJ/CITY2 - A Famous City]]
- [[http://acm.hdu.edu.cn/showproblem.php?pid=4328][HDU/4328 - Cut the cake]]

** RMQ-ST 优化

* DLX 跳舞链
- [[http://poj.org/problem?id=3074][POJ/3074 - Sudoku]]，[[http://www.cnblogs.com/AndreMouche/archive/2011/02/24/1964136.html][学姐的博客]]
#+include "~/acm/_templetes/DLX(跳舞链)/poj3074.cpp" src cpp

* pack 背包
#+include "~/acm/_templetes/背包/pack.cpp" src cpp

* Coding Skills
** 数组模拟链表
#+include "~/acm/_templetes/前向星/edge-vertex.cpp" src cpp

** 输入处理
uva11827
#+include "~/acm/_templetes/_string2int/string2int_uva11827.cpp" src cpp

