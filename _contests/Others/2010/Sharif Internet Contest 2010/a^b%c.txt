


Çóa ^ b mod mµÄÖµ£º
      if (phi(m) < b)
        a ^ b = a ^ (b mod phi(m) + phi(m)) (mod m);  
        
        
////////////////////////////////////////////////////////////////////////////


const int N = 100000;
const int M = 100000000;

int prime[N];
int use[N] = {0};

int phi(int m)
{
    int i;
    int a = m;
    for(i = 1; i <= prime[0]; i ++)
    {
        if(m % prime[i] == 0)
        {
            a = a / prime[i] * (prime[i]-1);
            while(m % prime[i] == 0)
			{
				m /= prime[i];
			}
            if(m == 1)
			{
				break;
			}
        }
    }
    if(m != 1)
    {
        a = a / m * (m-1);
    }
    return a;
}


void rep()
{
    int i,j, len = 1;
    prime[1] = 2;
    for(i = 3;i <= N; i += 2)
    {
        if(!use[i])
        {
            prime[++len] = i;
            for(j = 1; j *i <= N; j ++)
			{
				use[i*j] = 1;
			}
        }
    }
    prime[0] = len;
}



bool flag ;
__int64 solve(__int64 b, int c, __int64 mod) // b ^ c % mod;
{
	__int64 s, z, su, qq;
    if(c == 1)
    {
        if(b >= mod)
        {
            flag = true;
			return b%mod;
        }
		else
		{
			flag = false;
			return b;
		}
    }

    s = phi(mod);
    z = solve(b, c-1, s);
    
	if(flag) 
	{
		z += s;
	}
    su= 1;
    flag = false;
    
    if(b >= mod)
	{
        b %= mod;
        qq = 1;
    }
    else
	{
		qq = 0;
	}
    while( z > 0 )
    {
        if(z & 1)
        {
            su = su * b;
            if(su >= mod )
            {
                su %= mod; flag = true;
            }
            if(!flag && qq == 1)
			{
				flag = true;
			}
        }
        z >>= 1;
        b = b*b;
        if(b >= mod)
        {
            b %= mod;
            qq = 1;
        } 
    }
    return su;
}
